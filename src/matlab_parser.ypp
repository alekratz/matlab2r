%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations

%define parser_class_name {matlab_parser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%code requires
{
    #include <string>
    #include <vector>
    #include <cstdint>
    #include "ast.hpp"
    class matlab2r_driver;
}

%param { matlab2r_driver& driver }
%printer { yyoutput << $$; } <*>;

%initial-action
{
    // Initialize the initial location
    @$.begin.filename = @$.end.filename = &driver.streamname;
}

%code
{
    #include "matlab2r_driver.hpp"
    #include "matlab_lexer.hpp"
    #include <sstream>
    #undef yylex
    #define yylex driver.lexer->lex
}

// Tokens
%token
    END     0       "end of file"
    NEWLINE 10      "newline"
    BREAK
    CASE
    CATCH
    CLEAR
    CONTINUE
    ELSE
    END_KEYW
    ELSEIF
    FOR
    FUNCTION
    GLOBAL
    IF
    OTHERWISE
    PERSISTENT
    RETURN
    SWITCH
    TRY
    WHILE
    AMUL
    APOW
    ADIV
    ARDIV
    TRANSPOSE
    NCTRANSPOSE
    LE_OP
    GE_OP
    EQ_OP
    NE_OP
    TILDE
    SEMICOLON
    COMMA
    COLON
    EQUALS
    LPAREN
    RPAREN
    LBRACKET
    RBRACKET
    LBRACE
    RBRACE
    AMP
    MINUS
    PLUS
    TIMES
    FSLASH
    BSLASH
    LT_OP
    GT_OP
    POW
    VBAR
    DOT

%token <std::string>        IDENTIFIER
%token <std::string>        CONSTANT
%token <std::string>        STRING_LITERAL
%token <std::string>        NAKED_ARG

%type <ast::qualified_id_p>         qualified_id
%type <ast::qualified_id_item_p>    qualified_id_item
%type <ast::unary_op_p>             unary_op

%left VBAR
%left AMP
%left GT_OP GE_OP LT_OP LE_OP EQ_OP NE_OP
%left PLUS MINUS
%left TIMES FSLASH BSLASH POW AMUL ADIV ARDIV APOW

%%

%start matlab_unit;

matlab_unit
        /* : empty_lines function_declare_list */
        : statement_list { }
        ;

eostmt  : COMMA { }
        | SEMICOLON { }
        | NEWLINE { }
        ;

eostmt_or_eof
        : COMMA { }
        | SEMICOLON { }
        | NEWLINE { }
        | END { }
        ;

/******************************************************************************
 * Function decls
 *****************************************************************************/

function_declare
        : FUNCTION function_declare_lhs eostmt statement_list optional_end { }
        | FUNCTION func_return_list EQUALS function_declare_lhs eostmt statement_list optional_end { }
        ;

optional_end
        : END_KEYW eostmt_or_eof { }
        | %empty { }
        ;

func_return_list
        : IDENTIFIER { }
        | LBRACKET func_ident_list RBRACKET { }
        ;

function_declare_lhs
        : IDENTIFIER { }
        | IDENTIFIER LPAREN RPAREN { }
        | IDENTIFIER LPAREN func_ident_list RPAREN { }
        ;

func_ident_list
        : IDENTIFIER { }
        | IDENTIFIER COMMA func_ident_list { }
        ;

/******************************************************************************
 * Statements
 *****************************************************************************/

statement_list
        : statement statement_list_tail { }
        | %empty { }
        ;

statement_list_tail
        : statement statement_list_tail { }
        | %empty { }
        //| error { yyerrok; }
        ;

statement
        : global_statement { }
        | clear_statement { }
        | assignment_statement { }
        | selection_statement { }
        | iteration_statement { }
        | jump_statement { }
        | try_catch_statement { }
        | function_declare { }
        | naked_funcall { }
        | expression_statement { }
        | eostmt { }
        ;

naked_funcall
        : IDENTIFIER IDENTIFIER { driver.lexer->begin_naked_args(); } naked_args eostmt_or_eof { }
        | IDENTIFIER eostmt_or_eof
        ;

global_statement
        : GLOBAL identifier_list eostmt_or_eof { }
        ;

clear_statement
        : CLEAR identifier_list eostmt_or_eof { }
        | CLEAR eostmt_or_eof { }
        ;

expression_statement
        : expression eostmt_or_eof { }
        ;

assignment_statement
        : assignment_expression eostmt_or_eof { }
        ;

selection_statement
        : IF expression statement_list elseif_clause else_clause END_KEYW eostmt_or_eof { }
        /*
        | IF expression eostmt statement_list ELSE statement_list END_KEYW eostmt_or_eof
        | IF expression eostmt statement_list elseif_clause END_KEYW eostmt_or_eof
        | IF expression eostmt statement_list elseif_clause ELSE statement_list END_KEYW eostmt_or_eof
        */
        | SWITCH expression eostmt case_list otherwise_clause END_KEYW eostmt_or_eof { }
        ;

else_clause
        : ELSE statement_list { }
        | %empty { }
        ;

elseif_clause
        : ELSEIF expression statement_list elseif_clause { }
        | %empty { }
        ;

case_list
        : CASE expression eostmt statement_list case_list { }
        | eostmt case_list
        | %empty { }
        ;

otherwise_clause
        : OTHERWISE eostmt statement_list { }
        | %empty { }
        ;

iteration_statement
        : WHILE expression statement_list END_KEYW eostmt_or_eof { }
        | FOR IDENTIFIER EQUALS expression statement_list END_KEYW eostmt_or_eof { }
        | FOR LPAREN IDENTIFIER EQUALS expression RPAREN statement_list END_KEYW eostmt_or_eof { }
        ;

jump_statement
        : BREAK eostmt { }
        | CONTINUE eostmt { }
        | RETURN eostmt { }
        ;

identifier_list
        : IDENTIFIER { }
        | identifier_list IDENTIFIER { }
        ;

try_catch_statement
        : TRY statement_list catch_statement END_KEYW eostmt_or_eof { }
        | TRY statement_list END_KEYW eostmt_or_eof { }
        ;

catch_statement
        : CATCH IDENTIFIER statement_list { }
        | CATCH statement_list { }
        ;

naked_args
        : NAKED_ARG naked_args { }
        | %empty { }
        ;

/******************************************************************************
 * Expressions
 *****************************************************************************/

assignment_expression
        : postfix_expression EQUALS expression { }
        ;

assignment_lhs
        : IDENTIFIER
        ;

postfix_expression
        : primary_expression { }
        | postfix_expression TRANSPOSE { }
        | postfix_expression NCTRANSPOSE { }
        ;

primary_expression
        : qualified_id { }
        | STRING_LITERAL { }
        | CONSTANT { }
        | LBRACKET array_col_list RBRACKET { }
        | LBRACE array_col_list RBRACE { }
        | LPAREN expression RPAREN { }
        ;

expression
        : binary_expression { }
        | binary_expression COLON expression { }
        ;

binary_expression
        : unary_expression { }
        | binary_expression VBAR unary_expression { }
        | binary_expression AMP unary_expression { }
        | binary_expression EQ_OP unary_expression { }
        | binary_expression NE_OP unary_expression { }
        | binary_expression LT_OP unary_expression { }
        | binary_expression GT_OP unary_expression { }
        | binary_expression LE_OP unary_expression { }
        | binary_expression GE_OP unary_expression { }
        | binary_expression PLUS unary_expression { }
        | binary_expression MINUS unary_expression { }
        | binary_expression TIMES unary_expression { }
        | binary_expression FSLASH unary_expression { }
        | binary_expression BSLASH unary_expression { }
        | binary_expression POW unary_expression { }
        | binary_expression AMUL unary_expression { }
        | binary_expression ADIV unary_expression { }
        | binary_expression ARDIV unary_expression { }
        | binary_expression APOW unary_expression { }
        ;

unary_expression
        : unary_op postfix_expression { }
        | postfix_expression { }
        ;

unary_op
        : PLUS { $$ = std::make_shared<ast::unary_op>(ast::PLUS); }
        | MINUS { $$ = std::make_shared<ast::unary_op>(ast::MINUS); }
        | TILDE { $$ = std::make_shared<ast::unary_op>(ast::TILDE); }
        ;

array_or_funcall_tail
        : LPAREN index_expression_list RPAREN { }
        ;

array_cell_tail
        : LBRACE index_expression_list RBRACE { }
        ;

index_expression_list
        : index_expression { }
        | index_expression COMMA index_expression_list { }
        | %empty
        ;

index_expression
        : COLON { }
        | expression { }
        ;

qualified_id
        : qualified_id_item
        {
            $$ = std::make_shared<ast::qualified_id>($1);
        }
        | qualified_id_item DOT qualified_id
        {
            $3->add_front($1);
            $$ = $3;
        }
        ;

qualified_id_item
        : IDENTIFIER 
        { 
            $$ = std::make_shared<ast::qualified_id_item>();
            $$->identifier = $1;
        }
        | LPAREN expression RPAREN // apparently this is allowed
        {
            $$ = std::make_shared<ast::qualified_id_item>();
            // TODO : fill this out when expression is written
            //qualified_id_item->expression = $2;
        }
        | qualified_id_item array_or_funcall_tail
        {
            // TODO : fill this out when array_or_funcall_tail is written
            //$1->array_or_funcall_tail = $2;
            $$ = $1;
        }
        | qualified_id_item array_cell_tail { }
        {
            // TODO : fill this out when array_or_funcall_tail
            //$1->array_cell_tail = $2;
            $$ = $1;
        }
        ;

/******************************************************************************
 * Array indexing
 *****************************************************************************/

array_row_list
        : expression { }
        | expression COMMA { }
        | expression array_row_list { }
        | expression COMMA array_row_list { }
        | NEWLINE array_row_list { }
        | %empty
        ;

array_col_list
        : array_row_list { }
        | array_row_list SEMICOLON array_col_list { }
        | NEWLINE array_col_list { }
        ;

%%

void yy::matlab_parser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}


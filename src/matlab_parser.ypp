%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations

%define parser_class_name {matlab_parser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%code requires
{
    #include <string>
    #include <vector>
    #include <cstdint>
    class matlab2r_driver;
}

%param { matlab2r_driver& driver }
/* %printer { yyoutput << $$; } <*>; */

%initial-action
{
    // Initialize the initial location
    @$.begin.filename = @$.end.filename = &driver.streamname;
}

%code
{
    #include "matlab2r_driver.hpp"
    #include "matlab_lexer.hpp"
    #include <sstream>
    #undef yylex
    #define yylex driver.lexer->lex
}

// Tokens
%token
    END     0   "end of file"
    NEWLINE 10  "newline"
    IDENTIFIER  "identifier"
    CONSTANT    "literal"
    STRING_LIT  "string literal"
    TRANSPOSE   "transpose"
    NCTRANSPOSE "nctranspose"
    BREAK       "break keyword"
    CLEAR       "clear keyword"
    ELSE        "else keyword"
    ELSEIF      "elseif keyword"
    FOR         "for keyword"
    FUNCTION    "function keyword"
    GLOBAL      "global keyword"
    IF          "if keyword"
    RETURN      "return keyword"
    WHILE       "while keyword"
%%

%start matlab_unit;

matlab_unit
        : %empty { }
        ;

/*
// Rule types
%type <ast::line_list_p>        lines
%type <ast::line_list_p>        lines_tail
%type <ast::line_p>             line
%type <ast::conditional_p>      conditional
%type <ast::expr_p>             expr
%type <ast::for_stmt_p>         for_stmt
%type <ast::if_stmt_p>          if_stmt
%type <ast::else_stmt_p>        else_stmt
%type <ast::funcall_p>          funcall
%type <ast::funcall_p>          funcall_inner
%type <ast::args_list_p>        args_list
%type <ast::dimension_p>        dimension
%type <ast::qualified_id_p>     qualified_id
%type <ast::qualified_id_p>     qualified_id_tail
%type <ast::range_p>            range
 */


%%

void yy::matlab_parser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}


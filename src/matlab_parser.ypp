%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations

%define parser_class_name {matlab_parser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%code requires
{
    #include <string>
    #include <vector>
    #include <cstdint>
    class matlab2r_driver;
}

%param { matlab2r_driver& driver }
%printer { yyoutput << $$; } <*>;

%initial-action
{
    // Initialize the initial location
    @$.begin.filename = @$.end.filename = &driver.streamname;
}

%code
{
    #include "matlab2r_driver.hpp"
    #include "matlab_lexer.hpp"
    #include <sstream>
    #undef yylex
    #define yylex driver.lexer->lex
}

// Tokens
%token
    END     0       "end of file"
    NEWLINE 10      "newline"
    BREAK
    CASE
    CATCH
    CLEAR
    CONTINUE
    ELSE
    END_KEYW
    ELSEIF
    FOR
    FUNCTION
    GLOBAL
    IF
    OTHERWISE
    PERSISTENT
    RETURN
    SWITCH
    TRY
    WHILE
    AMUL
    APOW
    ADIV
    ARDIV
    TRANSPOSE
    NCTRANSPOSE
    LE_OP
    GE_OP
    EQ_OP
    NE_OP
    TILDE
    SEMICOLON
    COMMA
    COLON
    EQUALS
    LPAREN
    RPAREN
    LBRACKET
    RBRACKET
    LBRACE
    RBRACE
    AMP
    MINUS
    PLUS
    TIMES
    FSLASH
    BSLASH
    LT_OP
    GT_OP
    POW
    VBAR
    DOT

%token <std::string>        IDENTIFIER
%token <std::string>        CONSTANT
%token <std::string>        STRING_LITERAL
%token <std::string>        NAKED_ARG
/*
// Rule types
%type <ast::line_list_p>        lines
%type <ast::line_list_p>        lines_tail
%type <ast::line_p>             line
%type <ast::conditional_p>      conditional
%type <ast::expr_p>             expr
%type <ast::for_stmt_p>         for_stmt
%type <ast::if_stmt_p>          if_stmt
%type <ast::else_stmt_p>        else_stmt
%type <ast::funcall_p>          funcall
%type <ast::funcall_p>          funcall_inner
%type <ast::args_list_p>        args_list
%type <ast::dimension_p>        dimension
%type <ast::qualified_id_p>     qualified_id
%type <ast::qualified_id_p>     qualified_id_tail
%type <ast::range_p>            range
 */

%%

%start matlab_unit;

matlab_unit
        : function_declare_list
        | statement_list
        ;

eostmt
        : COMMA
        | SEMICOLON
        | NEWLINE
        ;

/******************************************************************************
 * Function decls
 *****************************************************************************/

function_declare_list
        : function_declare
        | function_declare function_declare_list
        ;

function_declare
        : FUNCTION function_declare_lhs eostmt statement_list
        | FUNCTION func_return_list EQUALS function_declare_lhs eostmt statement_list
        ;

func_return_list
        : IDENTIFIER
        | LBRACKET func_ident_list RBRACKET
        ;

function_declare_lhs
        : IDENTIFIER
        | IDENTIFIER LPAREN RPAREN
        | IDENTIFIER LPAREN func_ident_list RPAREN
        ;

func_ident_list
        : IDENTIFIER
        | IDENTIFIER COMMA func_ident_list
        ;

/******************************************************************************
 * Statements
 *****************************************************************************/

statement_list
        : statement statement_list
        | %empty
        ;

statement
        : global_statement
        | clear_statement
        | assignment_statement
        | expression_statement
        | selection_statement
        | iteration_statement
        | jump_statement
        | try_catch_statement
        | no_paren_funcall_statement
        ;

global_statement
        : GLOBAL identifier_list eostmt
        ;

clear_statement
        : CLEAR identifier_list eostmt
        ;

expression_statement
        : eostmt
        | expression eostmt
        ;

assignment_statement
        : assignment_expression eostmt
        ;

selection_statement
        : IF expression statement_list END_KEYW eostmt
        | IF expression statement_list ELSE statement_list END_KEYW eostmt
        | IF expression statement_list elseif_clause END_KEYW eostmt
        | IF expression statement_list elseif_clause ELSE statement_list END_KEYW eostmt
        ;
        /* TODO : switch/case */

elseif_clause
        : ELSEIF expression statement_list elseif_clause
        | %empty
        ;

iteration_statement
        : WHILE expression statement_list END_KEYW eostmt
        | FOR IDENTIFIER EQUALS expression statement_list END_KEYW eostmt
        | FOR LPAREN IDENTIFIER EQUALS expression RPAREN statement_list END_KEYW eostmt
        ;

jump_statement
        : BREAK eostmt
        | CONTINUE eostmt
        | RETURN eostmt
        ;

identifier_list
        : IDENTIFIER
        | identifier_list IDENTIFIER
        ;

try_catch_statement
        : TRY statement_list CATCH IDENTIFIER statement_list END_KEYW eostmt
        | TRY statement_list CATCH eostmt statement_list END_KEYW eostmt
        ;

no_paren_funcall_statement
        : IDENTIFIER eostmt
        | IDENTIFIER IDENTIFIER { driver.lexer->begin_garbage_mode(); } naked_args eostmt
        ;

naked_args
        : NAKED_ARG naked_args
        | %empty
        ;

/******************************************************************************
 * Expressions
 *****************************************************************************/

assignment_expression
        : postfix_expression EQUALS expression
        ;

postfix_expression
        : primary_expression
        | array_or_function_call_expression
        | array_cell_expression
        | postfix_expression TRANSPOSE
        | postfix_expression NCTRANSPOSE
        ;

primary_expression
        : qualified_id
        | CONSTANT
        | STRING_LITERAL
        | LPAREN expression RPAREN
        | LBRACKET RBRACKET
        | LBRACKET array_list RBRACKET
        | LBRACE RBRACE
        | LBRACE array_list RBRACE
        ;

expression
        : or_expression
        | expression COLON or_expression
        ;

or_expression
        : and_expression
        | and_expression VBAR or_expression
        ;

and_expression
        : equality_expression
        | equality_expression AMP and_expression
        ;

equality_expression
        : additive_expression
        | additive_expression EQ_OP equality_expression
        | additive_expression NE_OP equality_expression
        | additive_expression LT_OP equality_expression
        | additive_expression GT_OP equality_expression
        | additive_expression LE_OP equality_expression
        | additive_expression GE_OP equality_expression
        ;

additive_expression
        : multiplicative_expression
        | multiplicative_expression PLUS additive_expression
        | multiplicative_expression MINUS additive_expression
        ;

multiplicative_expression
        : unary_expression
        | unary_expression TIMES multiplicative_expression
        | unary_expression FSLASH multiplicative_expression
        | unary_expression BSLASH multiplicative_expression
        | unary_expression POW multiplicative_expression
        | unary_expression AMUL multiplicative_expression
        | unary_expression ADIV multiplicative_expression
        | unary_expression ARDIV multiplicative_expression
        | unary_expression APOW multiplicative_expression
        ;

unary_expression
        : postfix_expression
        | unary_operator postfix_expression
        ;

unary_operator
        : PLUS
        | MINUS
        | TILDE
        ;

array_or_function_call_expression
        : IDENTIFIER LPAREN index_expression_list RPAREN
        ;

array_cell_expression
        : IDENTIFIER LBRACE index_expression_list RBRACE
        ;

index_expression_list
        : index_expression
        | index_expression COMMA index_expression_list
        ;

index_expression
        : COLON
        | expression
        ;

qualified_id
        : IDENTIFIER
        | IDENTIFIER DOT qualified_id
        ;

/******************************************************************************
 * Array indexing
 *****************************************************************************/

array_list
        : expression
        | expression array_list
        | expression COMMA array_list
        | expression SEMICOLON array_list
        ;

%%

void yy::matlab_parser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}

